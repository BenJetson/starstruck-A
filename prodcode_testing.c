#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  enc_fly_left,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  enc_fly_right,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port3,           chain,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           drive_frontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           drive_frontRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           drive_backRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           fly_left,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           fly_right,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           drive_backLeft, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robot_constants.h"

int X1, X2, Y1 = 0;
int threshold = 15;


void drive_control() {
	//Create "deadzone" for Y1/Ch3
	if(abs(vexRT[Ch3]) > threshold)
	Y1 = vexRT[Ch3];
	else
	Y1 = 0;
	//Create "deadzone" for X1/Ch4
	if(abs(vexRT[Ch4]) > threshold)
	X1 = vexRT[Ch4];
	else
	X1 = 0;
	//Create "deadzone" for X2/Ch1
	if(abs(vexRT[Ch1]) > threshold)
	X2 = vexRT[Ch1];
	else
	X2 = 0;

	//Remote Control Commands
	motor[drive_frontRight] = Y1 - X1 - X2;
	motor[drive_frontLeft]  = Y1 + X1 + X2;
  motor[drive_backRight]  = Y1 + X1 - X2;
	motor[drive_backLeft]   = Y1 - X1 + X2;
}


void set_flywheel_speed(char speed) {

		motor[fly_left] = speed;
		motor[fly_right] = speed;

		// For some reason, the PC I was using didn't like the
		// set multiple motors thing. Replaced it.

		/*setMultipleMotors(speed,
		motor[fly_left],
		motor[fly_right]);*/
}

void flywheel_control() {
	if(vexRT[Btn6D])
		set_flywheel_speed(MOTOR_OFF_COAST);
	else if(vexRT[Btn6U])
		set_flywheel_speed(MOTOR_MAX);
}

void chain_control() {
	if(vexRT[Btn5D])
		motor[chain] = MOTOR_OFF_COAST;
	else if(vexRT[Btn5U])
		motor[chain] = MOTOR_MAX;
}

task main() {
	// setPIDforMotor(motor[fly_left], true);
	// setPIDforMotor(motor[fly_right], true);

	// That PC also didn't like the PIDs.
	// Killed those too.

	while(true) {
		drive_control();
		flywheel_control();
		chain_control();
	}
}
