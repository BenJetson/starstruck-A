#pragma config(Motor,  port1,           wrist,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveFrontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveFrontRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           arm3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveBackLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveBackRight, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"




//*** BEGIN ROBOT SETTINGS ***

// Non-programmers can edit this section to
//   change robot behaviour without any
//   major programming required.

/* These boolean values will flip axes.
   If the robot moves the wrong way when using the
     analog stick, you will need to invert that axis.
   Just change the values from true/false to fix it.
*/
bool invertAxis1 = false; // Strafe left/right
bool invertAxis3 = true; // Clockwise/Counterclockwise rotation
bool invertAxis4 = false; // Move forwards/backwards

// Amount analog stick must be moved
//   before motion will begin.
int threshold = 15;


//*** END ROBOT SETTINGS ***




// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// IF YOU ARE NOT A TEAM PROGRAMMER:
// DO NOT MODIFY CODE BELOW THIS LINE!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

int X1, X2, Y1 = 0;

int analogShift(int inputValue) {
	int result = (53/2) * pow(inputValue, (1/3));
	return (0 <= result < 127) ? (result) : (127);
}

void driveControl() {

	getJoystickSettings(joystick);

  // Y1 & Ch4
	if(abs(vexRT[Ch4]) > threshold) {
		Y1 = (!invertAxis4) ? (vexRT[Ch4]) : (-1 * vexRT[Ch4]);
		Y1 = analogShift(Y1);
	}	else {
		Y1 = 0;
	}

	// X1 & Ch3
	if(abs(vexRT[Ch3]) > threshold) {
		X1 = (!invertAxis3) ? (vexRT[Ch3]) : (-1 * vexRT[Ch3]);
		X1 = analogShift(X1);
	}	else {
		X1 = 0;
	}

	// X2 & Ch1
	if(abs(vexRT[Ch1]) > threshold) {
		X2 = (!invertAxis1) ? (vexRT[Ch1]) : (-1 * vexRT[Ch1]);
		X2 = analogShift(X2);
	}	else {
		X2 = 0;
	}

	// Compute values and send to motors
	motor[driveFrontRight] = Y1 - X1 + X2;
	motor[driveFrontLeft]  = Y1 + X1 + X2;
	motor[driveBackRight]  = Y1 + X1 - X2;
	motor[driveBackLeft]   = Y1 - X1 - X2;

}

void armControl() {

	getJoystickSettings(joystick);

	if (vexRT[Btn6U] == 1 || joy1Btn(6) == 1) {
		motor[arm1] = 127;
		motor[arm2] = 127;
		motor[arm3] = 127;
	} else if (vexRT[Btn6D] == 1 || joy1Btn(8) == 1) {
		motor[arm1] = -127;
		motor[arm2] = -127;
		motor[arm3] = -127;
	} else {
		motor[arm1] = 0;
		motor[arm2] = 0;
		motor[arm3] = 0;
	}
}

void wristControl() {

	getJoystickSettings(joystick);

	if (vexRT[Btn5D] == 1 || vexRT[Btn5U] == 1 ||
		  joy1Btn(5)   == 1 || joy1Btn(7)   == 1){
		motor[wrist] = 127;
  } else {
    motor[wrist] = 0;
	}
}

task main() {
	while (true) {

		driveControl();
		wristControl();
		armControl();

	}
}
