#pragma config(Motor,  port1,           wrist,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveFrontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveFrontRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           arm3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveBackLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveBackRight, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"




//*** BEGIN ROBOT SETTINGS ***

// Non-programmers can edit this section to
//   change robot behaviour without any
//   major programming required.

/* These boolean values will flip axes.
 *   If the robot moves the wrong way when using the
 *     analog stick, you will need to invert that axis.
 *   Just change the values from true/false to fix it. */
bool invertAxis1 = false; // Strafe left/right
bool invertAxis3 = true; // Clockwise/Counterclockwise rotation
bool invertAxis4 = false; // Move forwards/backwards

// Enable or disables sensetivity.
bool ENABLE_SENSETIVITY = false;

/* Amount analog stick must be moved
 *   before motion will begin. */
const int THRESHOLD = 15;

/* Changes the sensetivity factor for analog sticks.
 *   Should be an integer less than (55/2), but
 *     greater than zero.
 *   Lower values may cap your speed! */
const int CTRL_SENSETIVITY = (55/2);


//*** END ROBOT SETTINGS ***




/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * IF YOU ARE NOT A TEAM PROGRAMMER:
 * DO NOT MODIFY CODE BELOW THIS LINE!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

int X1, X2, Y1 = 0;

int analogShift(int inputValue) {

	if (!ENABLE_SENSETIVITY) {
		return inputValue;
	}

	int result = CTRL_SENSETIVITY * (pow(inputValue, (1/3)));

	if (result < -127) {
		return -127;
	}	else if (result > 127) {
		return 127;
	}	else {
		return result;
	}

}

void driveControl() {

	getJoystickSettings(joystick);

  // Y1 & Ch4
	if(abs(vexRT[Ch4]) > THRESHOLD) {
		Y1 = (!invertAxis4) ? (vexRT[Ch4]) : (-1 * vexRT[Ch4]);
		Y1 = analogShift(Y1);
	}	else {
		Y1 = 0;
	}

	// X1 & Ch3
	if(abs(vexRT[Ch3]) > THRESHOLD) {
		X1 = (!invertAxis3) ? (vexRT[Ch3]) : (-1 * vexRT[Ch3]);
		X1 = analogShift(X1);
	}	else {
		X1 = 0;
	}

	// X2 & Ch1
	if(abs(vexRT[Ch1]) > THRESHOLD) {
		X2 = (!invertAxis1) ? (vexRT[Ch1]) : (-1 * vexRT[Ch1]);
		X2 = analogShift(X2);
	}	else {
		X2 = 0;
	}

	// Compute values and send to motors
	motor[driveFrontRight] = Y1 - X1 + X2;
	motor[driveFrontLeft]  = Y1 + X1 + X2;
	motor[driveBackRight]  = Y1 + X1 - X2;
	motor[driveBackLeft]   = Y1 - X1 - X2;

}

void armControl() {

	getJoystickSettings(joystick);

	if (vexRT[Btn6U] == 1 || joy1Btn(6) == 1) {
		motor[arm1] = 127;
		motor[arm2] = 127;
		motor[arm3] = 127;
	} else if (vexRT[Btn6D] == 1 || joy1Btn(8) == 1) {
		motor[arm1] = -127;
		motor[arm2] = -127;
		motor[arm3] = -127;
	} else {
		motor[arm1] = 0;
		motor[arm2] = 0;
		motor[arm3] = 0;
	}
}

void wristControl() {

	getJoystickSettings(joystick);

	if (vexRT[Btn5D] == 1 || vexRT[Btn5U] == 1 ||
		  joy1Btn(5)   == 1 || joy1Btn(7)   == 1){
		motor[wrist] = 127;
  } else {
    motor[wrist] = 0;
	}
}

task main() {
	while (true) {

		driveControl();
		wristControl();
		armControl();

	}
}
